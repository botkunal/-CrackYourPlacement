// class Solution {
// public:
//     int mctFromLeafValues(vector<int>& arr) {
//         int n = arr.size();
//     vector<vector<int>> dp(n, vector<int>(n, INT_MAX));
//     vector<vector<int>> maxVal(n, vector<int>(n, 0));
    
//     // Precompute max values for subarrays
//     for (int i = 0; i < n; ++i) {
//         maxVal[i][i] = arr[i];
//         for (int j = i + 1; j < n; ++j) {
//             maxVal[i][j] = max(maxVal[i][j - 1], arr[j]);
//         }
//     }
    
//     // DP computation
//     for (int len = 1; len < n; ++len) {
//         for (int i = 0; i + len < n; ++i) {
//             int j = i + len;
//             for (int k = i; k < j; ++k) {
//                 int leftPart = dp[i][k];
//                 int rightPart = dp[k + 1][j];
//                 int rootValue = maxVal[i][k] * maxVal[k + 1][j];
//                 dp[i][j] = min(dp[i][j], leftPart + rightPart + rootValue);
//             }
//         }
//     }
    
//     return dp[0][n - 1];
//     }
// };
class Solution {
public:
    int mctFromLeafValues(vector<int>& arr) {
        int ans=0;
        stack<int> st;
        st.push(INT_MAX);

        for(int num:arr){
            while(!st.empty() && st.top()<=num){
                int mid=st.top();
                st.pop();
                ans+=mid*min(st.top(),num);
            }
            st.push(num);
            
        }
        while(st.size()>2){
            int mid=st.top();
            st.pop();
            ans+=st.top()*mid;
        }
        return ans;
    }
};
